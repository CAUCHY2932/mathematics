

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>code review &mdash; 吕阳阳的日志小屋 1.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'./',
              VERSION:'1.0',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="天文学" href="chapter14_astronomy.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> 吕阳阳的日志小屋
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Content:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="chapter00_preface.html">写在前面</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter01_python.html">python</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter02_data_science.html">数据科学</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter03_bi.html">bi</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter04_devops.html">环境</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter05_java.html">java</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter06_cs_base.html">计算机科学基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter07_offshore_oil_and_gas.html">海洋油气工程</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter08_big_data.html">大数据</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter09_other.html">其他</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter10_strategy.html">哲学与谋略</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter11_chat.html">随便聊聊</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter12_concept.html">概念</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter13_manage.html">管理学定律</a></li>
<li class="toctree-l1"><a class="reference internal" href="chapter14_astronomy.html">天文学</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">code review</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#code-review1">code review1</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">一、流程和规则</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">二、执行</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">三、收获</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">四、总结</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#code-review2">code review2</a></li>
<li class="toctree-l2"><a class="reference internal" href="#codereview">如何进行CodeReview</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#review">本地Review</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id5">远端Review</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id6">团队协作时的CodeReview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">关于CodeReview的一些原则</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id8">架构/设计/常规</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id19">代码风格</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">吕阳阳的日志小屋</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>code review</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/chapter15_code_review.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="code-review">
<h1>code review<a class="headerlink" href="#code-review" title="Permalink to this headline">¶</a></h1>
<div class="section" id="code-review1">
<h2>code review1<a class="headerlink" href="#code-review1" title="Permalink to this headline">¶</a></h2>
<p>前几天看了《Code Review 程序员的寄望与哀伤》，想到我们团队开展Code Review也有2年了，结果还算比较满意，有些经验应该可以和大家一起分享、探讨。
我们为什么要推行Code Review呢？我们当时面临着代码混乱、Bug频出的状况。
当时我觉得要有所改变，希望能提高产品的代码质量，改善开发团队面临的困境。并且我个人在开发上有很多经验，也希望这些知识能够在团队内传播。
各种考虑后，我们最后认为推行Code Review能改善或解决我们面临的很多问题。</p>
<p>这篇文章的目的不是告诉大家怎么在一个团队内推行Code Review，首先因为我个人仅在一家公司内推行过，并没有很多经验。
其次每家公司、每个团队的情况都不太一样，应该根据公司或团队的实际情况选择恰当的方案，并根据成员的反馈来及时调整，推动Code Review的实施。
所以，本文是介绍我们公司是如何实施Code Review的，我们是如何解决我们遇到的问题的，希望我们的经验能给大家带来些帮助。
行文仓促，如有遗漏或错误，欢迎指正。</p>
<div class="section" id="id1">
<h3>一、流程和规则<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>经过简单的对比、试用，我们最后采用了Git Flow+Pull Request（PR）模式来做Code Review。（PR模式详情可参见 <a class="reference external" href="http://blog.jobbole.com/76854/">Git工作流指南：Pull Request工作流</a>）</p>
<p>Pull Request(PR)简单的说就是你没有权限往一个特定的仓库或分支提交代码，你请求有权限的人把你提交的代码从你的仓库或分支合并到指定的仓库或分支。
由于PR需要有权限的人确认，所以非常适合在这个过程中做Code Review，是否接受或者拒绝就取决于Code Review的结果。
在支持PR模式的软件里，每一个PR都有一个新增代码的对比（diff）界面。
代码审核者可以在线浏览请求合并的新增代码，并针对有疑问的代码行添加评论，通过这种方式来实现Code Review。
评论可以被所有有权限查看仓库的人看到，每个人都可以回复任何人的评论，有点像论坛里某个帖子的讨论。
这种模式是事后审核，也就是代码已经提交到了中心仓库，Review过程中频繁的改动会造成历史签入记录的混乱。
当然Git可以采用更改历史记录来解决这个问题，由于容易误操作，我们一般只在基础类库这类要求比较严格的项目上实施。</p>
<p>我们所了解到的支持PR模式的软件都采用Git作为源代码版本控制工具，所以我们的源代码版本控制工具也迁移到了Git。
由于Git太灵活了，因此诞生了很多的Git流程，用来规范Git的使用。
常见的有<a class="reference external" href="http://blog.jobbole.com/76847/">集中式工作流</a>、<a class="reference external" href="http://blog.jobbole.com/76857/">功能分支工作流</a>、<a class="reference external" href="http://blog.jobbole.com/76867/">Gitflow工作流</a>、<a class="reference external" href="http://blog.jobbole.com/76861/">Forking工作流</a>、<a class="reference external" href="https://guides.github.com/introduction/flow/">Github工作流</a>。[</p>
<p>](https://guides.github.com/introduction/flow/)我们对Git Flow做了些调整，调整后的流程被命名为Baza Flow，定义见后文。
根据Baza Flow，我们大部分仓库只定义了2个主干分支，master和develop。(例外，我们有一个仓库有3个开发小组同时进行开发，定义了4个主干分支，目前还比较顺畅，再多估计主干分支之间的合并就比较繁琐了。)
master对应生产环境代码，所有面向生产环境的发布来源都是master分支的代码。develop则对应本地测试环境的代码。
绝大多数情况下，QA（测试）只测试develop分支和master分支的代码。</p>
<p>由于开发人员都在一个团队内，所以我们没有采用基于仓库的PR，采用的是基于分支的PR。
我们对主干分支的操作权限做了限制，只有特定的人才能操作，develop分支是项目开发Leader和架构师，master分支是QA。
有权限往主干分支合并的成员会按照约定的规则来执行合并，不会合并没有完成审核的PR。
上面这点其实蛮重要的，所以我们会对有权限合并的人有特别的约定，在什么情况下才能合并代码。（见后文PR的说明）
PR的发起人要主动的推动PR的审核，Leader也会密切关注PR审核的进度，在需要的时候及时介入。</p>
<p>我们配置了CI服务器（<a class="reference external" href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html">什么是CI</a>）只编译特定的分支，通常是develop和master分支。
所有的代码合并到了主干分支之后，都会自动触发编译和本地测试环境的发布，QA无需依赖开发人员编译的代码来测试，也无需自己手工操作这些，保证了开发人员和测试人员的相互独立。
我们本地测试环境的发布包含了数据库和站点的发布，全自动的，发布完成以后就是一个可用的产品，有时间这部分也可以分享一下。</p>
<p>我们还使用了Scrum里面一个很重要的概念：完成定义。
就是我们规定了我们一个任务的完成被定义为：代码编写完成，经过自测，提交的PR经过审核并且合并到主干分支。
也就是说，所有的代码被合并到了主干分支之后任务才算是完成，而被合并到主干分支必须要经过Code Review，这是强制的。</p>
<p>由于我们的托管软件对于Pull Request的限制，我们对Git Flow做了改动，改动的地方有：
1、每一个大功能我们会创建一个单独的feature分支，项目开发人员基于这个单独的feature分支创建自己的任务分支。
比如，对于CS 2项目来说，启动的时候分支的创建是：master -&gt; develop -&gt; feature/v2。
开发人员应该基于这个大特性分支feature/v2来创建自己的任务分支，比如创建XXXX，可以用一个单独的分支feature/v2-xxxx。
完成这个任务以后，立即向上游分支（feature/v2）提交pull request。然后从feature/v2-xxxx 创建自己的下一个任务分支，比如YYYY编辑 feature/v2-yyyy。
<strong>请注意，合并到上游分支的功能必须相对独立而且是可用的，分支任务工作量0.5-1个工作日，不宜超过2个工作日，超过2个工作日不向上游合并，需要向团队解释。</strong>
代码经过Review以后，可能会进行必要的修改，修改在原分支修改，修改完毕代码合并进上游分支，<strong>原分支会定期删除</strong>。
项目组成员在收到合并成功的通知后，请自行从上游大特性分支向下合并到自己当前的开发分支。
<strong>提交pull request后创建新任务分支的时候务必知会一下相关配合同事（比如前端的同事），让他们在新的分支上继续开发。</strong></p>
<p>2、对于小功能，预计在0.5-1个（不超过2个）工作日工作量的开发任务，直接基于develop分支创建特性分支即可。</p>
<p>3、在各个分支遇到的bug，请基于该分支创建一个Bug分支。
如果在缺陷跟踪管理系统上有对应的项，命名请使用缺陷跟踪管理系统的ID，比如<a class="reference external" href="http://192.168.1.10:8080/browse/BAZABUG-1354">BAZABUG-1354</a> 比如这个Bug的分支命名就是bugfix/BAZABUG-1354。
如果在缺陷跟踪管理系统上没有对应的项，命名请简短的说明修改内容，比如“JX 9df2b01 引用bootstrap css虚拟路径重写，避免出现字体无法找到的问题”，分支命名可以是bugfix/miss-font。
完成修改以后提交并推送到中心仓库然后立即向上游分支提交pull request。
4、发起pull request以后，<strong>请将pull request的链接在IM上发给代码审核者</strong>，以此通知对方及时进行审核。</p>
</div>
<div class="section" id="id2">
<h3>二、执行<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>我们在团队内部提倡质量优先，开发团队不能为了进度牺牲质量，并在团队内部达成了共识。
所以，无论进度有多么紧迫，Code Review的过程都一定会做。
所有的问题一定会被提出，只是会根据进度的紧迫程度，以及问题的大小，改动成本，决定问题是现在解决，还是加一个TODO，并记录在缺陷跟踪管理系统内，以防日后遗忘。
多数情况下，我们都会要求立即解决，哪怕因此造成了发布的推迟。
我们深知，其实多数情况下，现在不解决，日后不知道猴年马月才能解决。</p>
<p>我们在团队内推行Code Review的过程中没有遇到太多阻力。
原因大概有两点，首先管理层方面了解之前遇到的各种问题，也迫切希望能有所改善，所以从一开始就是支持的态度。
其次，绝大部分开发人员觉得在这个过程中能自己能学习到东西，并没有抵触，遇到很好的意见时大家都还是很高兴的。
最后，慢慢的形成了一种氛围，整个团队都会自觉的维护它。
附一张我们审核的对话图，这位童鞋尝试对系统内部散落各地发业务邮件的代码做一个整理，用一套模式来处理，调整了3版才定调，然后修改了很多细节才通过了合并，前后大概用一个多星期时间：</p>
<p>表面上看来Code Review会延缓项目的进度，但是在我们2年多的执行过程中，大多数时候没感觉到有延缓。
原因是，虽然代码合并的周期变长了，但是由于代码质量提高了，导致Bug变少了，由于Bug引起的返工问题也变少了，因此整体的进度其实并没有延缓。
我个人认为对一个成熟的团队其实做Code Review反而会加快整体的项目进度，但是手头上没有统计数据支撑我的观点。（对于软件开发的度量，欢迎有心得的同学告知我）</p>
<p>我们每个分支有权限合并的人都不止一个，这样可以保证有人请假不在的时候，代码仍然可以被其他同事审核通过之后合并。</p>
<p>半年前，我们团队加入了很多新成员，刚加入的新同事对规范、项目、产品的熟悉程度都不高，导致了有一段时间，我们遇到了PR审核周期变长的问题。
加上之前遇到的一些问题，我们总结了一个说明，目的是减轻Code Review对开发人员工作的负担，加快PR审核通过的过程。
说明如下：</p>
<blockquote>
<div><p>Pull Request 的说明</p>
<p>任务完成才能提交PR。
PR应该在一个工作日内被合并或者被拒绝。
PR在有严重问题（包括但不限于架构问题、安全问题、设计问题），太多问题，或者任务无效的情况下会被拒绝。
严禁一个PR里面有多个任务，除非它们是紧密关联的。
PR提交之后只允许针对Review发现问题再次提交代码，除非有充足的理由，严禁在同一个PR中再次提交其它任务的代码。</p>
<p>提交PR时候有一个描述框，内容会自动根据Commit的message合并而成。
切记，如果一次提交的内容包含很多Commit，请不要使用自动生成的描述。
请用简短但是足够说明问题的语言（理想是控制在3句话之内）来描述：</p>
<p><em>你改动了什么，解决了什么问题，需要代码审查的人留意那些影响比较大的改动。 特别需要留意，如果对基础、公共的组件进行了改动，一定要另起一行特别说明。</em></p>
<p>审核人员邀请原则：</p>
<p>\1. 在创建PR时，Reviewers（审核人）一栏里主要填写“必需审核人”。只有这些人审核都通过，才允许合并。
\2. 除了“必需审核人”外，还有一些其它审核人，我们可以在Description里做为“邀请审核嘉宾”&#64;进来。
\3. 主干分支间的合并，如Develop =&gt; Master，或Master =&gt; Develop等，则需要把整个团队（开发+QA）都列为“必需审核人”。</p>
<p>必须审核人的列表由团队决定，可能包括以下人选：</p>
<ul class="simple">
<li>团队Leader</li>
<li>前端架构师（如果有前端代码改动） （可以授权）</li>
<li>后端架构师（如果有后端代码改动） （可以授权）</li>
<li>产品架构师</li>
<li>对此PR解决的问题比较熟悉的（之前一直负责这部分业务的同事）</li>
<li>此PR解决的问题对他影响比较大（比如认领的任务依赖此PR的同事）</li>
</ul>
<p>其它审核人，包括但不限于：</p>
<p>需要知悉此处代码改动的人但又不必非要其审核通过的同事
可以从这个PR中学习的同事</p>
<p>可以授权指的是，根据约定，Bug修复之类的改动，或者影响较小的改动，前端架构师和后端架构师可以授权团队内的某个资深开发人员，由这个资深开发人员代表他们进行审核。
主干分支之间的合并，大型Feature的合并，前端架构师和后端架构师需要参与。</p>
<p>上述审核人关注的视角不太一样：
团队Leader关注你是否完成了任务，前后端架构师关注是否符合公司统一的架构、风格、质量，产品架构师从整个产品层面来关注这个PR。
熟悉此问题的同事可以更好的保证问题被解决，确保没有引入新问题。
被影响的同事可以及时了解他受到的影响。</p>
<p>团队Leader或者产品架构师如果觉得PR邀请的审核者不足或者过多，必须调整为合适的人员，其它同事可以在评论中建议。</p>
</div></blockquote>
</div>
<div class="section" id="id3">
<h3>三、收获<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>我们团队实施Code Review收获不少，总结出来大概有以下几点：</p>
<p>1、短期内迅速提高了代码质量。
原因有几个，大家知道自己的代码会被人审核之后写得会比较认真。
理论上代码质量是由整个团队内最优秀的那个人决定的。
大家也能在Review的过程中学习到其它同事优秀的编码。</p>
<p>2、Bug数量迅速减少。
但是这个我们没有数据统计比较，比较遗憾。
我和QA聊过，他给我的数据是在我们的一个新项目每2周一次的大发布，平均只会发现1~2个Bug。
这点提高了整个团队的幸福感，大家不用经常被火烧眉毛。</p>
<p>3、团队成员对项目的熟悉程度会比较均衡。
新同事通过参与Code Review能很快熟悉团队的规范。
代码不会只有个别人了解、熟悉，Bug谁都能改，新功能谁都能做。
对公司来说避免了人员的风险，对个人来说比较轻松（谁都能来帮你），可以选自己喜欢的任务做。</p>
<p>4、改善团队的氛围
Review的过程中会需要非常多的沟通，多沟通能拉近团队成员的距离。
并且无论级别高低，大家的代码都是要经过Review的，可以在团队内营造一个平等的氛围。
每个成员都可以审查别人的代码，这很容易激发他们的积极性。</p>
<p>亮一下我们的数据:</p>
<p>我们从2014年1月17日开始第一个PR的提交，到2016年7月5日一共发出了6944个PR，其中6171个通过，739个拒绝。日均11.85个PR，最多的一天提了55个PR。
这些PR一共产生了30040个评论，平均每个PR有4.32个评论，最多的一个PR有239个评论。
参与上述PR评论的同事一共有53位，平均每位同事发出了539个评论，最多的用户发出了5311个评论，最少的发了1个（刚推行Code Review就离职的同事）。
需要说明一下，只有简单的问题会通过评论来提出。比较复杂的，比如涉及到架构、安全等方面的问题，其实都会面对面的沟通，因为这样效率更高。</p>
</div>
<div class="section" id="id4">
<h3>四、总结<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>虽然有合适的工具支持会更容易实施Code Review，但它本身并不特别依赖具体的工具，所以前文并没有具体指明我们用了什么工具，除了Git。
原因是基于分支的PR流程依赖于大量创建分支，而Git创建一个分支非常的简单，所以PR模式+Git是一个很好的搭配。
我们在切换到Git之前，也做Code Review，采用的是提交代码以后把commit的Id发给相关同事来审查的流程。
审核通过以后会在缺陷跟踪管理系统里面评论，QA同事没见到审核通过的评论就认为任务没有完成，拒绝进行测试。
虽然没有现在这样直接方便，但是也还是做起来了。</p>
<p>PR审核的过程中，新加入的团队成员常见的问题是不符合代码规范之类的，其实是可以通过源代码检查工具来解决的，这部分我们一直在计划中（( ╯□╰ )），并没有开始实施。</p>
</div>
</div>
<div class="section" id="code-review2">
<h2>code review2<a class="headerlink" href="#code-review2" title="Permalink to this headline">¶</a></h2>
<p>CodeReview的目的是提升代码质量，尽早发现潜在缺陷与BUG，降低修复成本，同时促进团队内部知识共享，帮助更多人更好地理解系统。</p>
</div>
<div class="section" id="codereview">
<h2>如何进行CodeReview<a class="headerlink" href="#codereview" title="Permalink to this headline">¶</a></h2>
<p>如果使用Object-C进行开发，CodeReview分为两个阶段：本地 Review、远端 Review</p>
<div class="section" id="review">
<h3>本地Review<a class="headerlink" href="#review" title="Permalink to this headline">¶</a></h3>
<p>使用<a class="reference external" href="https://link.jianshu.com/?t=http%3A%2F%2Foclint.org">OCLint</a>来进行本地走查，关于其安装和使用，参考文章：
<a class="reference external" href="https://www.jianshu.com/p/cfeb191d1ff2">OCLint 代码静态分析</a>
<a class="reference external" href="https://www.jianshu.com/p/c8b3b515ccf3?from=groupmessage">自动化 Code Review</a>
<a class="reference external" href="https://link.jianshu.com/?t=http%3A%2F%2Fios.jobbole.com%2F85016%2F%3Futm_source%3Dblog.jobbole.com%26utm_medium%3DrelatedPosts">OCLint 安装与使用</a></p>
<p><a class="reference external" href="https://link.jianshu.com/?t=http%3A%2F%2Fios.jobbole.com%2F84809%2F">OCLint 规则与结果分析</a></p>
</div>
<div class="section" id="id5">
<h3>远端Review<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>远端 Review 和 本地 Review 大体相似，区别在与引用构建的脚本的对象从 Xcode 变成了 Jenkins CI ，报告的展示者从 Xcode 变成了 SonarQube 。
具体流程也在<a class="reference external" href="https://www.jianshu.com/p/c8b3b515ccf3?from=groupmessage">自动化 Code Review</a>文章中可以找到。
以上过程可以说还是在自我检查阶段。</p>
</div>
<div class="section" id="id6">
<h3>团队协作时的CodeReview<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>在团队（尤其是大规模团队）协作中，一般需要有人工Review的过程，如使用gitflow或其他协作工具，代码提交更新时，需要先经过CodeReview，通过后才允许合并，参考文章：
<a class="reference external" href="https://link.jianshu.com/?t=http%3A%2F%2Fblog.csdn.net%2Fuxyheaven%2Farticle%2Fdetails%2F49773619">从零开始Code Review</a>
<a class="reference external" href="https://link.jianshu.com/?t=http%3A%2F%2Fwww.cnblogs.com%2Fcnblogsfans%2Fp%2F5075073.html">Git 在团队中的最佳实践–如何正确使用Git Flow</a></p>
</div>
<div class="section" id="id7">
<h3>关于CodeReview的一些原则<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id8">
<h4>架构/设计/常规<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<div class="section" id="id9">
<h5>1.单一职责原则<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h5>
<p>一个类只能干一个事情，一个方法最好也只干一件事情。比较常见的违背是一个类既干UI的事情，又干逻辑的事情，这个在低质量的客户端代码里很常见。</p>
</div>
<div class="section" id="id10">
<h5>2.行为是否统一<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h5>
<p>例如：
1)缓存是否统一
2)错误处理是否统一
3)错误提示是否统一
4)弹出框是否统一
5)……</p>
</div>
<div class="section" id="id11">
<h5>3.代码污染<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h5>
<p>代码有没有对其他模块强耦合</p>
</div>
<div class="section" id="id12">
<h5>4.重复代码–&gt;应该抽取<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h5>
</div>
<div class="section" id="id13">
<h5>5.开闭原则<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h5>
</div>
<div class="section" id="id14">
<h5>6.面向接口编程<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h5>
</div>
<div class="section" id="id15">
<h5>7.健壮性<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h5>
<p>1)是否考虑线程安全
2)数据访问是否一致性
3)边界处理是否完整
4)逻辑是否健壮
5)是否有内存泄漏
6)有没有循环依赖
7)有没有野指针
8)是否检查了数组的“越界“错误
9)……</p>
</div>
<div class="section" id="id16">
<h5>8.错误处理<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h5>
</div>
<div class="section" id="id17">
<h5>9.改动是不是对代码的提升<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h5>
<p>新的改动是打补丁，让代码质量继续恶化，还是对代码质量做了修复</p>
</div>
<div class="section" id="id18">
<h5>10.效率/性能<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h5>
<p>1)关键算法的时间复杂度多少？有没有可能有潜在的性能瓶颈
2)客户端程序对频繁消息和较大数据等耗时操作是否处理得当</p>
</div>
</div>
<div class="section" id="id19">
<h4>代码风格<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h4>
<div class="section" id="id20">
<h5>1.可读性<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h5>
<p>衡量可读性的可以有很好实践的标准，就是 Reviewer 能否非常容易的理解这个代码。如果不是，那意味着代码的可读性要进行改进</p>
</div>
<div class="section" id="id21">
<h5>2.命名<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h5>
<p>1)命名对可读性非常重要
2)是否跟系统属性命名造成冲突
3)英语用词尽量准确一点，必要时可以查字典</p>
</div>
<div class="section" id="id22">
<h5>3.函数长度/类长度<a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h5>
<p>1)函数太长的不好阅读
2)类太长了，检查是否违反的 单一职责 原则</p>
</div>
<div class="section" id="id23">
<h5>4.注释<a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h5>
<p>恰到好处的注释,不是注释越多越好</p>
</div>
<div class="section" id="id24">
<h5>5.参数个数<a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h5>
<p>不要太多，一般不要超过 3 个</p>
<div class="highlight-markdown notranslate"><div class="highlight"><pre><span></span>在 Tumblr，review 代码对于所有的工程师来说，都是一项十分重要的工作，甚至比写代码本身更重要。我们的代码仓库被数百人共享，所以，我们不仅要写最好的代码，还要尽量使写出来的代码易于理解。而这一切的关键因素就是花时间 review 别人的代码，保证一切都是有条不紊的进行。
在 Tumblr，代码的所有的改动都是通过在一个内部的 github 服务上提交申请（Pull request, **以下简称PR**）的方式完成的。我们的代码仓库里面同时存放着 PHP 写的后端，数据库模式， swift/Obj-C 写的 iOS 应用，JAVA/Kotlin 写的 Android 应用，Go/C/C++ 写的基础架构，以及其他 Scala，Node.js，Python 或其他语言写的项目。我们所有的代码仓库都是由代码作者提交 PR，然后再由同事进行审阅，最后再合入到主分支并发布到生产环境对用户提供服务。
从我加入 Tumblr 以来，我个人 review 代码的方式发生了巨大的变化。以前，我主要是自己写代码然后在一小撮人里 review；现在在 Tumblr，庞大的代码仓库有者数百名贡献者，变化之大可想而知。幸运的是，我遇到了很多好的前辈。开始的时候我一个月 review 一个 PR，现在我平均每周需要 review 25个 PR。以下是我在 review 代码期间遵循的一些基本原则，这些原则使得我能够及时 review 代码，并能给他人带来帮助。

## 你需要知道你在给谁 review 代码

在收到 PR 的时候，我关注的第一件事情是：「谁写的这段代码？TA 是初级工程师还是资深工程师？TA 是刚接触到这部分代码还是开发多年的老鸟？我以前是否 review 过 TA 的代码？我对这段代码所属的模块是否熟悉？」
当我 review 我熟悉的人的代码的时候，我十分清楚 TA 写这段代码的时候是怎么想的，

并且我知道 TA 在写代码可能遇到什么问题。初级工程师的常常需要更多手把手的指导，比如为他们提供更多的样例代码和参考；资深工程师则需要提醒他们注意他们写的高性能，抽象或者讨巧的代码是很难阅读的，所以需要写更多的注释和文档。
另外，在对 review 的代码写评论的时候，也需要注意让除了提 PR 的作者本人之外的人能够看懂。因为：

1. 有些人是通过别人review代码的评论学习的；
2. 对初级工程师而言，这是帮助他们理解Turmble代码复杂性的方法。在六个月之内，你很可能会再次阅读这段代码，并理解它是如何运作的，如果有一段有意义的 code review 评论在那里，你也就更容易知道当初这段代码为什么这么写，以及他是如何工作的。

## review 代码的时候也需要想着其他人

我 review 代码的关键在于，无论谁提交代码改动的时候，都需要知道这段改动本身的的含义以及做出这写改动的动机和上下文。对我来说，理想情况是任何一个人看到这个 PR，都有足够的上下文去理解相应的改动，TA 能够知道这段改动为什么要这么写以及它究竟是如何工作的。特别是陈年的老代码和共享的代码仓库，也许三年之后，有人还会需要从这个 PR 去理解它做了什么。如果做不到上面说的需求的话，或者这次 PR 里面甚至都没有任何的上下文信息，那就一定是有问题的。细节总归是越多越好。
我从来不担心代码风格或者语法的问题，因为我们有自动化的流程来保证新代码或者改动是符合我们的代码要求的。正如我在[我是如何写代码的](https://link.jianshu.com/?t=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%3A%2F%2Fengineering.tumblr.com%2Fpost%2F156934724082%2Fhow-i-code-now)说的，我需要的有清楚的文档（随代码的注释和专门的文档）的，易于理解（哪怕不是那么讨巧）的的代码。我宁愿阅读有十倍代码量但是易于理解的代码，而不是仅一行的复杂难懂的多重嵌套，特别是这段代码的作者已经在这里堵了好几次，并且被那些陈年的，没有文档的“聪明&quot;代码折腾得要死的时候。
我觉得我能够理解这次代码的改动之后，我还会从一个不怎么了解这部分代码的人的角度重新审视它（因为下次我也可能 review 不了解的代码），并思考如何如何使得这份代码更加清晰。我会试着从一个刚入职六个月的新手的角度来看这段代码，并理解它是如何工作的。

## 懂得 PR 的影响面

很多时候单个的 PR 并不能把所有的事情工作的完成。在 Tumblr，我们总是试图让每个 PR 都尽可能的小，那样的话我们就能够快速且安全的进行代码 review，而不必要攒到 5000 行改动才进行 review。因此，一些大的工作需要被分解成小的片段，有些 PR 负责构建基础的组件，有些 PR 则是完成了基础实现之后做的。
换句话说，一些代码常常有一些待完成的事项或者以后需要修正的点，那么在代码里面标注好`TODO`，写下待办事项的名字和具体的工作，就是十分常见的行为了。这样，我们就不用等到完成了所有的代码之后再提交这次 PR 了。

## 关注整个代码 review 的过程

帮助我及时 review 代码，并且跟进整个 review 过程的主要工具是：邮件。我会检查我收到的每一份 github 邮件，我并不保证仓库里面的所有改动都会通知到我，但是我会检查我收到的任何一封跟 PR 相关的邮件。我就是依靠这种方式跟进整个 reivew 过程的，因为这个来回理想情况下不会超过一整天。

在 Tumblr，大多数的 reviewer 是自动的在 PR 作者里面轮流选出来的。摊派任务的时候会给我发送一封邮件，并把跟这个PR相关的所有信息都和我关联起来。自此以后，我就需要一直关注我的邮件，并保证我不仅要抽时间尽快 review 代码，还需要跟进这次 PR 中作者对我提的评论进行的对应的修改。

## 记住你是一个「人」

无论是在 review 代码还是写代码的过程中，必须要始终记得一件事情：你是一个「人」，并且你 review 的代码的作者也是一个「人」。
通过 review 代码让他们觉得受到质疑对你们都有好处。在你写建议，有问题或者发现 TA 没注意到一个边界条件的时候，保持友善的态度。即使是写了多年“完美无缺”代码的老鸟，有些时候也应该把他们当作会犯错误的普通人来看待。即使那些与你共事很久的人并不在意你拿他们开玩笑，总会有新人不理解的。
记住，被很多人分享的，并且在不断更新的代码必然往往是奇怪的、复杂的，特别是那些已经存在了十多年的代码。记住，很多时候工作是十分仓促的，你要做的就是在有限的时间完成尽可能优质的代码。我们并不能为了完美的代码耽搁项目进度，但是我们需要保证我们写的每一份代码尽可能的好，无论我们在写代码还是在 review 代码。
</pre></div>
</div>
</div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="chapter14_astronomy.html" class="btn btn-neutral float-left" title="天文学" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019@young

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>